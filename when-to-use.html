<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>When to Use - hevm</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="book.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="getting-started.html">Getting Started</a></li><li class="chapter-item affix "><a href="install.html">Quick Installation</a></li><li class="chapter-item affix "><a href="when-to-use.html" class="active">When to Use</a></li><li class="chapter-item affix "><li class="part-title">Tutorials</li><li class="chapter-item "><a href="ds-test-tutorial.html">ds-test tutorial</a></li><li class="chapter-item "><a href="equivalence-checking-tutorial.html">Equivalence checking tutorial</a></li><li class="chapter-item affix "><li class="part-title">Reference</li><li class="chapter-item "><a href="test.html">ds-test proving</a></li><li class="chapter-item "><a href="symbolic.html">Symbolic unit execution</a></li><li class="chapter-item "><a href="equivalence.html">Equivalence checking</a></li><li class="chapter-item "><a href="exec.html">Concrete execution</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">hevm</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/ethereum/hevm" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="hhttps://github.com/ethereum/hevm/edit/main/src/when-to-use.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="when-to-use-symbolic-execution"><a class="header" href="#when-to-use-symbolic-execution">When to use Symbolic Execution</a></h1>
<p>In the cryptocurrency world, it is exceedingly easy to lose a <a href="https://chainsec.io/defi-hacks/">lot of
assets</a> due to bugs. While fuzz testing can
help find potential issues with digital contracts, it is a tool that can only
execute the program concretely, one execution at a time. In contrast, Symbolic
Execution can execute all potential values in a decision path &quot;in one go&quot;,
creating a symbolic expression out of a path, and checking whether it
can trigger a fault. Hence, Symbolic Execution tends to be more efficient at
finding bugs than fuzzing when the bugs are rare, or explicitly (i.e.
maliciously) hidden. Symbolic Execution can also <em>prove</em> that no postcondition
can be violated, increasing the overall confidence in the contract. Note, however,
that Symbolic Execution does not automatically generate postconditions for
well-known bug classes like static code analysis tools do. Instead, these
postconditions, and their sometimes associated preconditions, need to
be explicitly written.</p>
<h2 id="fuzzing-versus-symbolic-execution"><a class="header" href="#fuzzing-versus-symbolic-execution">Fuzzing versus Symbolic Execution</a></h2>
<p>Fuzzing tests usually have a set of (sometimes implicit) pre- and
postconditions, but the actual action (e.g. function call) is performed by an
external entity, the fuzzer. For C/C++ fuzzing, the implicit postcondition is
often e.g. that the system does not throw a segmentation fault. For EVM
bytecode, postconditions need to be explicit. Let's see an example:</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
import &quot;ds-test/test.sol&quot;;

contract MyContract is DSTest {
  uint balance;
  function test_overflow(uint amt) public {
    unchecked {
     balance += amt;
    }
    assert(balance &gt;= amt);
  }
}
</code></pre>
<p>This function is easy to break by picking an <code>amt</code> that overflows <code>balance</code>,
so that the postcondition <code>balance &gt; amt</code> will not hold. A
<a href="https://en.wikipedia.org/wiki/Fuzzing">fuzzer</a> finds this kind of bug very
easily. However, fuzzers have trouble finding bugs that are either specifically
hidden (e.g. by a malicious developer), or that have a complicated code path
towards them. Let's see a simple one:</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
import &quot;ds-test/test.sol&quot;;

contract MyContract is DSTest {
  uint balance;
  function prove_multiply(uint amt, uint amt2) public {
    require(amt != 1);
    require(amt2 != 1);
    require(amt &lt; amt2);
    uint tmp;
    tmp = amt * amt2;
    if (tmp == 119274257) balance = 1337;
    else balance += tmp;
    assert(balance &gt;= tmp);
  }
}
</code></pre>
<p>Calling this contract with <code>amt = 9479</code> and <code>amt2 = 12583</code> will set the balance
to 1337 which is less than <code>amt*amt2</code>, breaking the postcondition. However, a
fuzzer, e.g. <a href="https://github.com/crytic/echidna">Echidna</a> will likely not find
those numbers, because <code>uint</code> has a potential range of <code>2**256</code> and so it'd be
looking for a needle in a haystack, when looking randomly. Here's how to run
Echidna on the multiplication test:</p>
<pre><code class="language-solidity">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;
contract MyContract {
 // the rest is the same
}
</code></pre>
<p>Then run:</p>
<pre><code>echidna --test-mode assertion src/multiply-test.sol
</code></pre>
<p>Echidna will terminate after 50k runs, with all tests passing. Notice that the
difference here, compared to the previous example, is that the overflow example
has <em>many</em> different inputs that can break the postcondition, whereas here only
one can.</p>
<p>Hevm finds the bug in both of these functions. This is because
hevm (and symbolic execution frameworks in general) try to find the bug via
proof-directed search rather than using random inputs. In hevm, we try to prove
that there are no inputs to the test case such that given the preconditions, the
postconditions can be broken. While trying to construct this mathematical proof,
hevm finds a <em>countereexample</em>, an  input that breaks the postconditions:</p>
<pre><code>$ hevm test
Checking 1 function(s) in contract src/multiply-test.sol:MyContract
[RUNNING] prove_multiply(uint256,uint256)
   [FAIL] prove_multiply(uint256,uint256)
   Counterexample:
     result:   Revert: 0x4e487b710000000000000000000000000000000000000000000000000000000000000001
     calldata: prove_multiply(9479,12583)

Checking 1 function(s) in contract src/overflow-test.sol:MyContract
[RUNNING] prove_overflow(uint256)
   [FAIL] prove_overflow(uint256)
   Counterexample:
     result:   Revert: 0x4e487b710000000000000000000000000000000000000000000000000000000000000001
     calldata: prove_overflow(00000000000000000000000000000000000000000000000100000000000000000182dad8c17bd5e89e8043a08ada90a6d5efdee4425f85cb863109783e158ba4fba908a0e6fae6c6b51002)
</code></pre>
<h2 id="similarities-and-differences-to-other-tools"><a class="header" href="#similarities-and-differences-to-other-tools">Similarities and Differences to Other Tools</a></h2>
<p>Fuzzers are exceedingly fast and efficient when there are many potential faults
with a function/contract, or if the faults are of a type that's easy to search
for (e.g. off-by-one). However, they rarely, if ever, find cases where the bug
is hidden deep in the branch logic, or needs very specific input parameters.
Hence, it is best to use fuzzers at first to find easy-to-find bugs, as fuzzers
are very efficient at that. Then, once the tests pass the fuzzer, it is
recommended to use a symbolic execution engine such as hevm.</p>
<p>hevm is similar to <a href="https://github.com/a16z/halmos">Halmos</a> and
<a href="https://docs.runtimeverification.com/kontrol/overview/readme">Kontrol</a> in its
approach. However, it is quite different from static code analysis tools such
as <a href="https://github.com/enzymefinance/oyente">Oyente</a>,
<a href="https://github.com/crytic/slither">Slither</a>, and
<a href="https://github.com/ConsenSys/mythril">Mythril</a>. While these 3 tools typically
use some form of symbolic execution to try to validate their results, their
main method of operation is not via symbolic execution, and they can, and do,
report false positives.</p>
<p>Notice that static code analysis tools can find bugs that the author(s) didn't
write a test case for, as they typically have a (large) set of preconfigured
test-cases that they can report on, if they can find a way to violate them. Hence,
it may be valuable to run static analysis tools alongside symbolic execution tools
such as hevm.</p>
<p>Finally,
<a href="https://github.com/ethereum/solidity/blob/develop/docs/smtchecker.rst">SMTChecker</a>
may also be interesting to run alongside hevm. SMTChecker is very different
from both approaches detailed above. While SMTChecker is capable of reliably
finding both reentrancy and loop-related bugs, the tools above can only do so
on a best effort basis. Hevm often reports a warning of incompleteness for
such problems, while static code analysis tools either report potential
positives or may even not discover them at all.</p>
<div class="table-wrapper"><table><thead><tr><th>Tool</th><th>Approach</th><th>Primary Method</th><th>Notes</th></tr></thead><tbody>
<tr><td><strong>hevm</strong></td><td>Symbolic analysis of EVM bytecode</td><td>Symbolic execution</td><td>Focuses on exploring all execution possibilities, identifying potential assertion violations, and optimizing gas usage. Can prove equivalence between bytecodes.</td></tr>
<tr><td><strong>Halmos</strong></td><td>Similar to hevm</td><td>Not specified</td><td>Approach similar to hevm, but the document does not detail specific methodologies or differences.</td></tr>
<tr><td><strong>Kontrol</strong></td><td>Similar to hevm</td><td>Not specified</td><td>Approach similar to hevm, with a focus presumably on symbolic analysis as well, but further details are not provided in the document.</td></tr>
<tr><td><strong>Oyente</strong></td><td>Static code analysis</td><td>Partial symbolic execution</td><td>Uses symbolic execution to validate results but primarily relies on static analysis. Can report false positives.</td></tr>
<tr><td><strong>Slither</strong></td><td>Static code analysis</td><td>Partial symbolic execution</td><td>Similar to Oyente, uses static analysis as its main method, complemented by symbolic execution for validation. Known for reporting false positives.</td></tr>
<tr><td><strong>Mythril</strong></td><td>Static code analysis</td><td>Partial symbolic execution</td><td>Combines static code analysis with symbolic execution for result validation. Like Oyente and Slither, can report false positives.</td></tr>
<tr><td><strong>SMTChecker</strong></td><td>Different from both hevm and static code analysis tools</td><td>SMT solving</td><td>Capable of finding reentrancy and loop-related bugs reliably, which other tools might miss or report incompletely. Offers a distinct approach from symbolic execution.</td></tr>
</tbody></table>
</div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="install.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="ds-test-tutorial.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="install.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="ds-test-tutorial.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="solidity.min.js"></script>


    </div>
    </body>
</html>
